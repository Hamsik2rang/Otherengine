# 메모리

[English](../English/Memory.md)

## 메모리 풀

Otherengine은 메모리 풀을 사용합니다. 이렇게 하면 몇 가지 장점이 있습니다.

1. 메모리 단편화를 방지합니다. 이는 특히 메모리가 적은 모바일 디바이스나 콘솔에서 도움이 됩니다.
2. 반복적인 메모리 할당/해제에서 뛰어난 성능을 발휘합니다.
3. 캐시 지역성을 향상시킬 수 있습니다.

하지만 제약사항도 있습니다. 정적 객체 및 그 소유 객체는 메모리 풀을 사용할 수 없습니다. 정적 객체의 생성 시점에서는 메모리 풀이 초기화 되어있지 않기 때문입니다. 이 경우 메모리 풀을 사용하지 말고 C++ 표준 메모리 할당 메커니즘을 사용하면 됩니다.

메모리 풀에서 할당하려면 이렇게 하면 됩니다:

```cpp
#include "Memory.hpp"

class MyClass {...};
class MyDerived : public MyClass {...};

auto ptr = New<int>(4); // *ptr을 4로 초기화
Delete(ptr); // Delete<int>(ptr)

auto ptr2 = New<MyClass>(...); // MyClass의 생성자에 ... 전달
Delete(ptr2); // Delete<MyClass>(ptr2)

auto ptr_arr = NewArr<int>(5, ...) // int[5]; ...으로 초기화
DeleteArr(ptr_arr, 5) // 중요: 반드시 크기를 맞춰야 함

MyClass* ptr_upcast = New<MyDerived>(...);
Delete(ptr_upcast) // Delete<MyClass>(ptr_upcast)
// ^^^^^^^^^
// 절대로 이렇게 하시면 안됩니다
// 이유는 아래에서 자세히 설명...
```

메모리 풀의 크기는 고정되어 있습니다. 그래서 필요한 메모리 크기에 맞는 블록 집합을 선택해야 합니다. 예를 들어 612바이트의 메모리가 필요하면, 1024바이트짜리 블록 집합을 가지는 메모리 풀에서 할당합니다. 때문에 메모리를 해제할 때도 같은 크기의 메모리 풀에 반환해야 합니다.

`New<T>()`와 `Delete<T>()`는 `sizeof(T)`로 크기를 알아냅니다. 이는 객체 크기가 정적으로 추론된다는 의미입니다. 그래서 객체의 실제 크기가 아닌 포인터의 타입의 크기로 가정하여, **할당받았던 곳과 다른 메모리 풀에 반환하게 됩니다.** 이 경우 오류가 나중에 발생하기 때문에 **디버깅이 극도로 어렵습니다.**

아래에서 설명할 [`SharedPtr`]에서는 이런 문제가 없습니다. [`SharedPtr`]을 생성하는 시점에서 삭제자가 결정되기 때문입니다.

## [`SharedPtr`]

Otherengine의 동적 객체 관리는 스마트 포인터를 통해서 이루어집니다. 그 중 `shared_ptr`은 표준 라이브러리의 것을 사용하지 않고, 커스텀 [`SharedPtr`]을 사용합니다. 그 이유는 다음과 같습니다.

1. 메모리 풀 - 객체 생성 및 삭제를 메모리 풀에서 해야합니다.
2. 스레드 동기화 제거 - 객체를 여러 스레드가 공유하는 경우는 많지 않습니다.

새로운 shared 객체를 생성하려면 `std::make_shared` 대신 `MakeShared`를 사용합니다:

```cpp
#include "Templates/Pointer.hpp"

auto obj = MakeShared<T>(...);

// 커스텀 할당자 사용
MyAlloc<T> alloc;
auto alobj = AllocateShared<T>(alloc, ...);
```

`MakeShared`의 반환 타입은 [`SharedPtr`]이 아닌 [`SharedRef`]입니다. [`SharedRef`]는 null이 될 수 없는 [`SharedPtr`]입니다. 코드 전반에 [`SharedPtr`]대신 [`SharedRef`]를 사용하면 null 검사를 없앨 수 있고, 더 안전하고 읽기 쉬운 코드를 작성할 수 있습니다.

> **주의**: 객체가 삭제될 때 기본적으로 메모리 풀을 통하도록 되어있습니다. 때문에 raw 포인터에서 직접 생성하거나 `reset(p)`으로 참조 대상을 변경하는 경우, 반드시 메모리 풀에서 할당받은 객체만 사용하거나, 직접 적절한 삭제자를 지정해주어야 합니다.

[`SharedPtr`]: https://othereum.github.io/Otherengine/classoeng_1_1core_1_1_shared_ptr.html
[`SharedRef`]: https://othereum.github.io/Otherengine/classoeng_1_1core_1_1_shared_ref.html
